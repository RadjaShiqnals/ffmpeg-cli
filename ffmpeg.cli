#!/bin/bash

# ffmpeg-cli: A user-friendly, menu-driven FFmpeg command-line interface.
# v5.2: Implemented intelligent single-pass for NVENC target size.

# --- Global Variables ---
INPUT_FILE=""
VIDEO_CODEC=""
BITRATE=""
TARGET_SIZE="" # Stores target size in MB
RESOLUTION="" # Stores target width for scaling, e.g., "1920"
QUALITY_LEVEL="" # Stores CRF/CQP value
FRAMERATE=""
OUTPUT_FORMAT=""
AUDIO_TRACK_OPTION=""
OUTPUT_FILE=""
# This variable will be set to true if NVENC is available and usable.
NVENC_AVAILABLE=false

# --- Helper Functions ---

print_header() {
    term_width=$(tput cols)
    padding=$(printf '%0.1s' ={1..500})
    printf '\n%*.*s %s %*.*s\n' 0 "$(((term_width-2-${#1})/2))" "$padding" "$1" 0 "$(((term_width-1-${#1})/2))" "$padding"
}

show_error() {
    echo -e "\n\e[1;31mError: $1\e[0m"
    read -n 1 -s -r -p "Press any key to continue..."
}

show_success() {
    echo -e "\n\e[1;32m$1\e[0m"
}

check_nvenc() {
    # This command attempts a 1-frame transcode using NVENC.
    # It uses a virtual input (-f lavfi) so no actual file is needed.
    # If the command succeeds (exit code 0), NVENC is truly working.
    if ffmpeg -hide_banner -loglevel error -f lavfi -i nullsrc=s=hd720:d=1 -c:v h264_nvenc -f null - &>/dev/null; then
        NVENC_AVAILABLE=true
    else
        NVENC_AVAILABLE=false
    fi
}

# --- Core Logic ---

main_menu() {
    while true; do
        clear
        print_header "FFmpeg Interactive CLI"
        echo "FFmpeg Version: $(ffmpeg -version | head -n 1)"
        if [[ "$NVENC_AVAILABLE" == true ]]; then
            echo -e "NVIDIA NVENC Status: \e[1;32mDetected & Usable\e[0m"
        else
            echo -e "NVIDIA NVENC Status: \e[1;31mNot Usable by FFmpeg\e[0m"
        fi
        echo "========================================"
        if [[ -n "$INPUT_FILE" ]]; then
            echo -e "Current File: \e[1;33m$INPUT_FILE\e[0m"
        else
            echo "Current File: Not Selected"
        fi
        echo "----------------------------------------"
        echo "1. Choose Input File"
        if [[ -n "$INPUT_FILE" ]]; then
            echo "2. View File Information"
            echo "3. Set Conversion Options"
            echo "4. Start Conversion"
        fi
        echo "5. Exit"
        echo "========================================"
        read -rp "Select an option: " choice

        case $choice in
            1) choose_input_file ;;
            2) [[ -n "$INPUT_FILE" ]] && view_file_info || show_error "Invalid option." ;;
            3) [[ -n "$INPUT_FILE" ]] && conversion_options_menu || show_error "Invalid option." ;;
            4) [[ -n "$INPUT_FILE" ]] && start_conversion || show_error "Invalid option." ;;
            5) exit 0 ;;
            *) show_error "Invalid option. Please try again." ;;
        esac
    done
}

choose_input_file() {
    local file_path=""
    
    if command -v zenity &> /dev/null && [[ -n "$DISPLAY" ]]; then
        print_header "Choose File Selection Method"
        echo "1. Open Graphical File Manager (Recommended)"
        echo "2. Type Path Manually in Terminal"
        read -rp "Select an option: " method_choice
        
        if [[ "$method_choice" == "1" ]]; then
            file_path=$(zenity --file-selection --title="Choose a media file")
            if [[ $? -ne 0 ]]; then
                echo "File selection cancelled."
                sleep 1
                return
            fi
        else
            read -rep "Enter the path to your media file: " -i "$HOME/" file_path
        fi
    else
        print_header "Choose Input File"
        read -rep "Enter the path to your media file: " -i "$HOME/" file_path
    fi
    
    if [[ -f "$file_path" && -r "$file_path" ]]; then
        INPUT_FILE="$file_path"
        show_success "File selected successfully!"
        VIDEO_CODEC=""
        BITRATE=""
        TARGET_SIZE=""
        RESOLUTION=""
        QUALITY_LEVEL=""
        FRAMERATE=""
        OUTPUT_FORMAT=""
        AUDIO_TRACK_OPTION=""
        OUTPUT_FILE=""
    else
        if [[ -n "$file_path" ]]; then
            show_error "File does not exist or is not readable."
        fi
    fi
    sleep 1
}

view_file_info() {
    clear
    print_header "Media File Information"
    ffprobe -v error -hide_banner -pretty -show_format -show_streams "$INPUT_FILE"
    echo "========================================"
    read -n 1 -s -r -p "Press any key to return to the menu..."
}


conversion_options_menu() {
    if [[ -z "$INPUT_FILE" ]]; then
        show_error "Please choose an input file first (Option 1)."
        return
    fi

    local default_codec="libx264 (CPU)"
    if [[ "$NVENC_AVAILABLE" == true ]]; then
        default_codec="h264_nvenc (NVIDIA)"
    fi

    while true; do
        clear
        print_header "Conversion Options"
        echo -e "Input File: \e[1;33m${INPUT_FILE}\e[0m"
        echo "----------------------------------------"
        echo "--- Encoding Mode (Choose One) ---"
        if [[ -n "$QUALITY_LEVEL" ]]; then
            echo "1. Quality Level (CRF/CQP): ${QUALITY_LEVEL}"
            echo -e "2. Video Bitrate: \e[90m(Disabled by Quality Level)\e[0m"
            echo -e "3. Target File Size (MB): \e[90m(Disabled by Quality Level)\e[0m"
        elif [[ -n "$TARGET_SIZE" ]]; then
            echo "1. Quality Level (CRF/CQP): Not Set"
            echo -e "2. Video Bitrate: \e[1;32mAutomatic (Targeting ${TARGET_SIZE} MB)\e[0m"
            echo "3. Target File Size (MB): ${TARGET_SIZE}"
        else
            echo "1. Quality Level (CRF/CQP): Not Set"
            echo "2. Video Bitrate: ${BITRATE:-Default (e.g., 5M)}"
            echo "3. Target File Size (MB): Not Set"
        fi
        echo "----------------------------------------"
        echo "--- Other Video Options ---"
        echo "4. Video Codec: ${VIDEO_CODEC:-Default ($default_codec)}"
        echo "5. Resolution (Width): ${RESOLUTION:-Original}"
        echo "6. Video Framerate: ${FRAMERATE:-Default (Original)}"
        echo "----------------------------------------"
        echo "--- Audio & Output ---"
        echo "7. Audio Track Handling: ${AUDIO_TRACK_OPTION:-Default (Copy first track)}"
        echo "8. Output Format: ${OUTPUT_FORMAT:-Default (mkv)}"
        echo "----------------------------------------"
        echo "9. Back to Main Menu"
        echo "========================================"
        read -rp "Select an option to change: " menu_choice

        case $menu_choice in
            1) select_quality ;;
            2) select_bitrate ;;
            3) select_target_size ;;
            4) select_video_codec ;;
            5) select_resolution ;;
            6) select_framerate ;;
            7) handle_audio_tracks ;;
            8) select_output_format ;;
            9) break ;;
            *) show_error "Invalid option." ;;
        esac
    done
}

select_quality() {
    print_header "Set Quality Level (CRF/CQP)"
    echo "This mode targets a specific visual quality."
    echo "Lower values mean higher quality and larger file size."
    echo "Recommended range for libx264 (CRF): 18-28. 23 is a good default."
    if [[ "$NVENC_AVAILABLE" == true ]]; then
        echo "Recommended range for NVENC (CQP): 20-30. 25 is a good default."
    fi
    read -rp "Enter quality value: " new_quality
    if [[ "$new_quality" =~ ^[0-9]+$ ]]; then
        QUALITY_LEVEL="$new_quality"
        BITRATE=""
        TARGET_SIZE=""
        show_success "Quality level set. Bitrate and Target Size are disabled."
    else
        show_error "Invalid input. Please enter a number."
    fi
    sleep 1
}

select_video_codec() {
    print_header "Select Video Codec"
    local options=()
    if [[ "$NVENC_AVAILABLE" == true ]]; then
        options+=("H.264 (NVIDIA NVENC)")
        options+=("H.265 / HEVC (NVIDIA NVENC)")
    fi
    options+=("libx264 (CPU)")
    options+=("Copy (No re-encoding)")

    for i in "${!options[@]}"; do
        echo "$((i+1)). ${options[$i]}"
    done
    echo "========================================"
    read -rp "Choose a codec: " codec_choice

    if [[ "$codec_choice" =~ ^[0-9]+$ && "$codec_choice" -gt 0 && "$codec_choice" -le "${#options[@]}" ]]; then
        local selected_option="${options[$((codec_choice-1))]}"
        
        if [[ "$selected_option" == *"H.264 (NVIDIA NVENC)"* ]]; then
            VIDEO_CODEC="h264_nvenc"
        elif [[ "$selected_option" == *"H.265 / HEVC (NVIDIA NVENC)"* ]]; then
            VIDEO_CODEC="hevc_nvenc"
        elif [[ "$selected_option" == *"libx264 (CPU)"* ]]; then
            VIDEO_CODEC="libx264"
        elif [[ "$selected_option" == *"Copy (No re-encoding)"* ]]; then
            VIDEO_CODEC="copy"
        fi
        show_success "Video codec set to $VIDEO_CODEC"
    else
        show_error "Invalid selection. No changes made."
    fi
    sleep 1
}

select_bitrate() {
    print_header "Set Video Bitrate"
    read -rp "Enter bitrate (e.g., 5M, 2500k): " new_bitrate
    if [[ -n "$new_bitrate" ]]; then
        BITRATE="$new_bitrate"
        TARGET_SIZE=""
        QUALITY_LEVEL=""
        show_success "Manual bitrate set. Other encoding modes disabled."
    else
        show_error "Bitrate cannot be empty."
    fi
    sleep 1
}

select_target_size() {
    print_header "Set Target File Size"
    read -rp "Enter target size in MB (e.g., 10, 500): " new_size
    if [[ "$new_size" =~ ^[1-9][0-9]*$ ]]; then
        TARGET_SIZE="$new_size"
        BITRATE=""
        QUALITY_LEVEL=""
        show_success "Target size set. Other encoding modes disabled."
    else
        show_error "Invalid input. Please enter a positive number."
    fi
    sleep 1
}

select_resolution() {
    print_header "Set Output Resolution"
    echo "Enter the desired width (e.g., 1920 for 1080p, 1280 for 720p)."
    echo "The height will be calculated automatically to preserve aspect ratio."
    read -rp "Enter new width (or leave blank for original): " new_width
    if [[ "$new_width" =~ ^[1-9][0-9]*$ ]]; then
        RESOLUTION="$new_width"
        show_success "Resolution width set to $new_width."
    elif [[ -z "$new_width" ]]; then
        RESOLUTION=""
        show_success "Resolution reset to original."
    else
        show_error "Invalid input. Please enter a positive number."
    fi
    sleep 1
}

select_framerate() {
    print_header "Set Framerate"
    read -rp "Enter framerate (e.g., 30, 60) or leave blank for original: " new_framerate
    FRAMERATE="$new_framerate"
}

handle_audio_tracks() {
    print_header "Audio Track Handling"
    audio_stream_count=$(ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 "$INPUT_FILE" | wc l)

    if [[ "$audio_stream_count" -le 1 ]]; then
        echo "Only one audio track detected. It will be copied by default."
        AUDIO_TRACK_OPTION="copy_first"
        sleep 2
        return
    fi
    
    echo "Multiple audio tracks detected ($audio_stream_count total)."
    echo "1. Copy only the first audio track."
    echo "2. Merge all audio tracks into one (stereo)."
    echo "3. Select a specific track to copy."
    read -rp "Choose an option: " audio_choice

    case $audio_choice in
        1) AUDIO_TRACK_OPTION="copy_first" ;;
        2) AUDIO_TRACK_OPTION="merge_all" ;;
        3) 
            read -rp "Enter the track number to copy (starts from 0): " track_num
            if [[ "$track_num" -ge 0 && "$track_num" -lt "$audio_stream_count" ]]; then
                AUDIO_TRACK_OPTION="copy_specific:$track_num"
            else
                show_error "Invalid track number."
            fi
            ;;
        *) show_error "Invalid selection." ;;
    esac
}

select_output_format() {
    print_header "Select Output Format"
    read -rp "Enter format (e.g., mkv, mp4, mov): " new_format
    if [[ -n "$new_format" ]]; then
        OUTPUT_FORMAT="$new_format"
    else
        show_error "Format cannot be empty."
    fi
}

# --- HEAVILY MODIFIED ---
# This function now contains all conversion logic and strategies.
start_conversion() {
    if [[ -z "$INPUT_FILE" ]]; then
        show_error "Please choose an input file first."
        return
    fi
    
    local default_codec="libx264"
    if [[ "$NVENC_AVAILABLE" == true ]]; then
        default_codec="h264_nvenc"
    fi
    local vcodec=${VIDEO_CODEC:-$default_codec}
    
    local format=${OUTPUT_FORMAT:-mkv}
    
    if [[ "$vcodec" == "copy" && (-n "$RESOLUTION" || -n "$QUALITY_LEVEL") ]]; then
        show_error "Cannot use Resolution Scaling or Quality Level with 'copy' codec."
        return
    fi

    local dirname=$(dirname "$INPUT_FILE")
    local filename=$(basename -- "$INPUT_FILE")
    local extension="${filename##*.}"
    local filename_noext="${filename%.*}"
    OUTPUT_FILE="${dirname}/${filename_noext}_converted.${format}"

    local video_filters=""
    if [[ -n "$RESOLUTION" ]]; then
        video_filters="scale=${RESOLUTION}:-2"
    fi
    
    local cmd_video_filters=""
    if [[ -n "$video_filters" ]]; then
        cmd_video_filters="-vf ${video_filters}"
    fi

    local audio_opts=""
    case "$AUDIO_TRACK_OPTION" in
        "copy_first") audio_opts="-map 0:a:0? -c:a copy" ;;
        "merge_all") audio_opts="-filter_complex \"[0:a]amerge=inputs=$(ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 "$INPUT_FILE" | wc -l)[aout]\" -map \"[aout]\" -c:a aac -b:a 128k" ;;
        "copy_specific:"*) local track_index=${AUDIO_TRACK_OPTION#*:} && audio_opts="-map 0:a:$track_index? -c:a copy" ;;
        *) audio_opts="-map 0:a:0? -c:a copy" ;;
    esac

    # --- MAIN LOGIC BRANCH ---

    if [[ -n "$QUALITY_LEVEL" ]]; then
        # Quality-based encoding (always single-pass)
        local quality_param=""
        if [[ "$vcodec" == "libx264" || "$vcodec" == "libx265" ]]; then
            quality_param="-crf $QUALITY_LEVEL"
        else
            quality_param="-cq $QUALITY_LEVEL -rc vbr"
        fi
        
        local cmd="ffmpeg -i \"$INPUT_FILE\" -c:v $vcodec $quality_param $cmd_video_filters $audio_opts -c:s copy -y \"$OUTPUT_FILE\""
        execute_command "$cmd"

    elif [[ -n "$TARGET_SIZE" ]]; then
        # Target-size encoding strategy depends on codec
        local duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$INPUT_FILE")
        local total_bitrate=$(echo "($TARGET_SIZE * 1024 * 1024 * 8) / $duration" | bc)
        local audio_bitrate=128000
        local video_bitrate=$(echo "$total_bitrate - $audio_bitrate" | bc)
        local video_bitrate_k=$(echo "$video_bitrate / 1000" | bc)

        if [[ "$vcodec" == *"nvenc"* ]]; then
            # --- STRATEGY 1: Single-pass for NVENC ---
            clear
            print_header "Target Size (Single-Pass for NVENC)"
            echo "Using a single-pass strategy suitable for NVIDIA NVENC."
            echo "Calculated video bitrate: ${video_bitrate_k}k"
            local cmd="ffmpeg -i \"$INPUT_FILE\" -c:v $vcodec -b:v ${video_bitrate_k}k $cmd_video_filters $audio_opts -c:s copy -y \"$OUTPUT_FILE\""
            execute_command "$cmd"
        else
            # --- STRATEGY 2: Two-pass for CPU encoders ---
            local logfile="/tmp/ffmpeg2pass-$$"
            rm -f ${logfile}*
            local pass1_cmd="ffmpeg -y -i \"$INPUT_FILE\" -c:v $vcodec -b:v ${video_bitrate_k}k $cmd_video_filters -pass 1 -passlogfile $logfile -an -f null /dev/null"
            local pass2_cmd="ffmpeg -i \"$INPUT_FILE\" -c:v $vcodec -b:v ${video_bitrate_k}k $cmd_video_filters -pass 2 -passlogfile $logfile $audio_opts -c:s copy \"$OUTPUT_FILE\""
            execute_two_pass_command "$pass1_cmd" "$pass2_cmd" "${video_bitrate_k}k"
        fi

    else
        # Standard bitrate encoding (single-pass)
        local cmd="ffmpeg -i \"$INPUT_FILE\" -c:v $vcodec"
        if [[ -n "$BITRATE" && "$vcodec" != "copy" ]]; then
            cmd+=" -b:v $BITRATE"
        fi
        if [[ -n "$FRAMERATE" && "$vcodec" != "copy" ]]; then
            cmd+=" -r $FRAMERATE"
        fi
        cmd+=" $cmd_video_filters $audio_opts -c:s copy -y \"$OUTPUT_FILE\""
        execute_command "$cmd"
    fi
}

# --- MODIFIED ---
# This function is now only for displaying the final command.
execute_command() {
    local cmd="$1"
    clear
    print_header "Ready to Convert"
    echo -e "The following command will be executed:\n\e[1;36m$cmd\e[0m\n"
    read -rp "Do you want to proceed? (y/n): " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        eval $cmd
        if [[ $? -eq 0 ]]; then
            show_success "Conversion completed successfully!"
            show_success "Output file: $OUTPUT_FILE"
        else
            show_error "Conversion failed. Check output."
        fi
        read -n 1 -s -r -p "Press any key to return to the main menu..."
    else
        echo "Conversion cancelled."
        sleep 1
    fi
}

# --- MODIFIED ---
# This function now only handles the execution of the two-pass process.
execute_two_pass_command() {
    local pass1_cmd="$1"
    local pass2_cmd="$2"
    local bitrate_display="$3"
    
    clear
    print_header "Ready for Two-Pass Conversion"
    echo "Calculated video bitrate: $bitrate_display"
    echo -e "Pass 1 command:\n\e[1;36m$pass1_cmd\e[0m\n"
    echo -e "Pass 2 command:\n\e[1;36m$pass2_cmd\e[0m\n"
    read -rp "Do you want to proceed? (y/n): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then echo "Cancelled."; sleep 1; return; fi

    echo "--- Starting Pass 1 ---"
    eval $pass1_cmd
    local logfile_base=${pass1_cmd#*passlogfile }
    logfile_base=${logfile_base%% *}
    if [[ $? -ne 0 ]]; then show_error "Pass 1 failed. Aborting."; rm -f ${logfile_base}*; return; fi
    
    echo "--- Starting Pass 2 ---"
    eval $pass2_cmd
    if [[ $? -eq 0 ]]; then
        show_success "Conversion completed!"
        show_success "Output file: $OUTPUT_FILE"
    else
        show_error "Pass 2 failed."
    fi
    rm -f ${logfile_base}*
    read -n 1 -s -r -p "Press any key to return to the main menu..."
}


# --- Script Entry Point ---
if ! command -v ffmpeg &> /dev/null || ! command -v bc &> /dev/null; then
    echo "Error: 'ffmpeg' and 'bc' are required."
    echo "On Ubuntu/Debian: sudo apt update && sudo apt install ffmpeg bc"
    exit 1
fi
if ! command -v zenity &> /dev/null; then
    echo "Warning: 'zenity' is not installed. GUI file picker will be unavailable."
    echo "To enable it, run: sudo apt install zenity"
fi

check_nvenc
main_menu
